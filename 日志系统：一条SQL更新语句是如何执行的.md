# 《MySQL实战45讲》学习笔记

[toc]







## 01.基础架构：一条SQL查询语句是如何执行的



MySQL基本架构示意图：

![](https://raw.githubusercontent.com/principlepeggy/imgForBlog/master/mysqlLogic.jpg)

以以下语句为例：

```mysql
SELECT * FROM T WHAERE ID = 10;
```





## 02.日志系统：一条SQL更新语句是如何执行的



Mysql可以恢复半个月内任意1秒的状态。

### 更新语句的执行流程

以一条更新语句为例：

```mysql 
CREATE TABLE T(ID int primary key,c int);

UPDATE T SET c=c+1 WHERE ID = 2;
```

更新语句的执行路径和查询语句类似：

![](https://raw.githubusercontent.com/principlepeggy/imgForBlog/master/mysqlLogic.jpg)



* 执行语句前先连接数据库

* 更新表会清空所有查询缓存。因此不建议使用查询缓存。

* 分析器知道这是一条更新语句，优化器使用ID这个索引，执行器负责找到这一行然后更新。

  与查询流程不同的是更新流程设计两个重要日志模块：redo log（重做日志）和binlog（归档日志）。

  ### 重要的日志模块：redo log

  在MySQl中，如果每一次更新都写进磁盘，磁盘再去找对应的记录再更新，会耗费很大的IO成本、查找成本，所以MySQL使用**WAL（Write Ahead Logging)技术**，先写日志，再写磁盘。

  具体为 当一条记录需要更新时，InnoDB引擎把记录先写到REDO LOG中并更新内存；在适当的时候InnoDB引擎将该操作记录到磁盘中，一般是系统空闲时。

  注意：InnoDB的redo log大小固定。从头开始写，写到末尾又回到开头循环写。

  ![](https://raw.githubusercontent.com/principlepeggy/imgForBlog/master/redolog-%E7%AC%AC%202%20%E9%A1%B5.drawio.png)

> write_pos:当前记录的位置，边写边后移且循环。
>
> checkpoint:当前要擦除的位置，向后移且循环。
>
> 他们之间时可以用来记录操作的空闲部分。当write_pos = checkpoint时，不能执行新更新，停下擦除一些记录，推进checkpoint。
>
> crash-safe: 数据库发生异常重启，之前提交的记录都不会丢失。

### 重要的日志模块：binlog

redo log是InnoDB特有的日志，binlog是server层的日志。

| redo log                         | binlog                                                 |
| -------------------------------- | ------------------------------------------------------ |
| InnoDB特有                       | 所有引擎都可以使用                                     |
| 物理日志：“在某数据页做了某修改” | 逻辑日志：“给某行某字段+1”                             |
| 循环写，空间固定会用完           | 追加写，写到一定大小后切换到下一个，不会覆盖之前的日志 |
| UPDATE语句的执行流程图：         |                                                        |

![](https://raw.githubusercontent.com/principlepeggy/imgForBlog/master/redolog-%E7%AC%AC%203%20%E9%A1%B5.png)

深色是在执行器中执行的，浅色框是在InnoDB内部执行的。

#### 两阶段提交

redo log的写入拆成了两个步骤：prepare和 commit。这就是两阶段提交，为了让两份日志的逻辑一致。

数据库恢复到半月前的任意一秒的状态：

找到最近的一次全量备份，从该备份恢复到临时库；从备份时间点开始，将备份的binlog取出，重放到想要恢复的那个时刻。此时临时库和彼时的线上库一致。

不使用两阶段提交的后果：

若写完第一个日志后，第二个日志写期间发生crash：

1.先写redo log ，后写binlog；恢复后无binlog的逻辑操作；

2.先写binlog，后写redolog；恢复后多了binlog的事务。

以上都是数据库的状态和用他的日志恢复出来的库状态不一致。

恢复数据在误操作时，及扩容时都会应用。

扩容的常用方法：全量备份加应用binlog实现。

redolog 和binlog都可以用于表示事务的提交状态，需要保持逻辑上的一致。

## 03.事务隔离

事务保证一组数据库操作，要么全部成功，要么全部失败。在引擎层实现，InnoDB支持事务。

事务有四大特性（ACID）：原子性、一致性、隔离性、持久性

### 隔离性与隔离级别

当数据库上有多个事务同时执行的时候，可能出现脏读、不可重复读、幻读的问题。隔离级别可解决这些问题。

> SQL标准的隔离级别：
>
> 读未提交（read uncommited):一个事务还没提交时，他做的变更就能被别的事务看到；
>
> 读提交（read commited):一个事务提交之后，他做的变更才会被其他事务看到；
>
> 可重复读(repeatable read)：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读级别下，未提交变更对其他事务不可见；
>
> 串行化(serializable)：对于同一行记录，写会加写锁，读会加读锁。出现读写锁冲突时，后访问的事务必须等前一个事务执行完成才能继续执行。

举例：

```mysql
CREATE TABLE T(c int) ENGINE=InnoDB;
INSERT INTO T(c) VALUES(1);
```

| 事务A                 | 事务B       |
| --------------------- | ----------- |
| 启动事务，查询得到值1 | 启动事务    |
|                       | 查询得到值1 |
|                       | 将1改成2    |
| 查询得到值V1          |             |
|                       | 提交事务B   |
| 查询得到值V2          |             |
| 提交事务A             |             |
| 查询得到值V3          |             |
|                       |             |

|      | 读未提交 | 读提交 | 可重复读 | 串行化 |
| ---- | -------- | ------ | -------- | ------ |
| V1   | 2        | 1      | 1        | 1      |
| V2   | 2        | 2      | 1        | 1      |
| V3   | 2        | 2      | 2        | 2      |
|      |          |        |          |        |

实现上，数据库内部创建视图，访问时以视图的逻辑结果为准。

| 读未提交                           | 读提交                          | 可重复读                                     | 串行化               |
| ---------------------------------- | ------------------------------- | -------------------------------------------- | -------------------- |
| 直接返回记录上的最新值，无视图概念 | 视图在每个SQL语句开始执行时创建 | 事务启动时创建，整个事务存在期间都使用该视图 | 加锁方式避免串行访问 |



ORACLE数据库默认隔离级别是读提交，从Oracle迁移到MySQL的应用要保证数据库隔离级别一致。

```mysql
transaction_isolation = READ-COMMITED
```

### 事务隔离的实现

以可重复读为例：

MySQL中每条记录更新时会同时记录一条回滚操作，通过回滚操作可以得到前一个状态的值。

数据库的多版本并发控制（MVCC）：不同时刻启动的事务有不同的read-view，同一条记录在系统中可以存在多个版本。

回滚日志的删除：系统判断在没有事务会需要用到回滚日志时，会被删除，即系统里没有比这个回滚日志更早的read-view时。

建议不要使用长事务：

1.占用大量存储空间，保存了很久前的事务视图及提交前所有的回滚记录

2.占用锁资源

### 事务的启动方式

1.显式启动事务语句：

```mysql
begin
start transaction
commit
rollback
```



2.关掉线程的自动提交，直到commit/rollback/断开连接

```mysql
set autocommit=0;
```

可能会导致意外的长事务。

因此建议显式启动事务。

”多一次交互“问题：

使用commit work and chain语法。提交事务并自动启动下一个事务，省去了再次执行begin的开销。从程序开发角度明确知道每个语句是否在事务中。

查询长事务：在information_schema库innodb_trx表中查询

```mysql
SELECT *  FROM information_schema.innodb_trx WHERE TIME_TO_SEC(TIMEDIFF(now(),trx_started))>60
```

## 04.深入浅出索引（上）

索引是为了提高数据查询的效率，相当于书的目录。

### 索引的常见模型

三种常见的数据结构：

1.哈希表

以键-值存储数据的结构。

当出现冲突，一种解决方案是在同一个键后建立链表存储不同的值。这种情况下值的存储不是有序的，所以哈希索引做区间查询的速度很慢。因此哈希表适用于只有等值查询的场景。比如Memcached及其他一些NoSQL引擎。

2.有序数组

在等值查询和范围查询场景的性能都很优秀。查询时使用二分法。单只适用于静态存储引擎。更新数据时需要挪动其他记录，成本很高。

3.二叉搜索树

查询和更新的时间复杂度都是O(logn)。实际使用中使用N叉树，减少磁盘访问次数，N取决于数据块的大小。

还有跳表、LSM树等数据结构也被应用于引擎设计。

MySQL中索引在存储引擎层实现，不同引擎索引工作方式也不同。InnoDB使用最广泛。

### InnoDB的索引模型

索引组织表：表根据主键顺序以索引形式存放

InnoDB使用B+树索引模型。每个索引对应一棵B+树。

举例：有一个主键列为ID的表，表中有字段k，并且k上有索引。

建表：

```mysql
CREATE TABLE T(
id int PRIMARY KEY,
k int NOT NULL,
name varchar(16),
INDEX(k)
)ENGINE=InnoDB;
```

插入（100，1）（200，2）（300，3）（500，5）（600，6）

ID:

![image-20221210151426907](C:\Users\Alsichkkan\AppData\Roaming\Typora\typora-user-images\image-20221210151426907.png)

K:

![image-20221210151524389](C:\Users\Alsichkkan\AppData\Roaming\Typora\typora-user-images\image-20221210151524389.png)

根据叶子节点的内容，索引分为主键索引和非主键索引。

主键索引的叶子节点存储整行数据，InnoDB里主键索引也被称为聚簇索引；

非主键索引里叶子节点存储主键的值，InnoDB里非主键索引被称为二级索引。

主键查询：

只需搜索ID这棵B+树。

```mysql
select * from T where ID =500
SELECT * FROM T WHERE K=5
```



普通查询：

先搜索k索引树，得到ID值再在ID索引树搜索，称为*回表*。

因此在应用中应该多使用主键查询。

### 索引维护

B+树在插入新值时需要维护索引有序性。

页分裂：某页数据已满，需挪动部分数据到新页。页分裂影响性能和数据页的利用率。

页合并：删除数据后会将数据页做合并。

#### 自增主键的使用场景

自增主键时自增列上定义的主键。

```mysql
NOT NULL PRIMARY KEY AUTO_INCREMENT
```

自增主键的插入数据模式是追加操作，不涉及挪动其他记录，也不会触发叶子结点分裂。

主键长度越小，普通索引的叶子结点越小，占用空间也就越小。

从性能和存储空间方面考量自增主键往往更合理。

直接使用业务字段做主键的场景：KV场景，即

1.只有一个索引；2.该索引必须是唯一索引

## 05.深入浅出索引（下）

### 覆盖索引

覆盖索引可以减少树的搜索次数，显著提升查询性能

### 最左前缀原则

对于高频请求，如根据市民身份证号查询姓名，可建立（身份证号，姓名）的联合索引，在这个请求上用到覆盖索引可以避免回表。

对于不频繁的请求，利用索引的最左前缀来定位记录。

只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

> 在建立联合索引时，如何安排索引字段内的顺序？
>
> 第一原则：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
>
> 第二原则：如果既有联合查询，又有基于a,b各自的查询，考虑a,b哪个字段占用空间小，就单独创建哪个的索引。

### 索引下推

MySQL5.6引入的索引下推优化（index condition pushdown）可以在索引遍历过程中对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

举例：

```mysql
SELECT * FROM tuser WHERE name LIKE '张%' AND age = 10 AND ismale = 1;
```

非索引下推，只是按顺序把“name第一个字是“张””的记录一条条取出来回表；

索引下推：在（name,age）索引内部就判断了age是否等于10，对于不等于10的记录直接判断并跳过。

## 06.全局锁和表锁

锁设计初衷是为了处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理控制资源的访问规则。

MySQL的锁大致分为全局锁、表级锁、行锁三类。

### 全局锁

对整个数据库实例加锁。

MySQL加全局读锁：FLUSH TABLES WITH READ LOCK

全局锁的典型使用场景：做全库逻辑备份



## 07.行锁功过



## 08.事务是隔离的还是不隔离的



## 09.普通索引和唯一索引



## 10.MySQL为什么有时选错索引



## 11.怎么给字符串字段加索引



## 12.为什么MySQL会”抖“一下

